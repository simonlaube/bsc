% !TEX root = ../Thesis.tex
\chapter{Conclusion}
In this thesis the goal was to find ways of improving the resource management and thus reduce storage and energy usage as much as possible while still having a system that lets us create a reliable network consisting of autonomous devices. TinySSB was used as a starting point and a resource manager was built on top to orchestrate the activity of TinySSB. \\
Using Micropython as the language let us develop the code quite rapidly. While most functionalities of Micropython worked without any problems on the LoPy 4 devices, the pure25519 verifying algorithm - which is an essential part of the project to sign packets - initially did not work. After fixing a function that did not run on the LoPy 4 we managed to get it working and were able to start testing the network. However verifying one packet still takes a couple of seconds and also quite a bit of computing power. A native implementation in C of this algorithm that can be called from within Micropython would probably be a huge improvement in terms of energy and time consumption. A frequent problem that was occurring were stack overflows. Due to the limited memory capabilities of the LoPy 4 devices a node can quickly overflow its memory. We first tried to verify incoming packets simultaneously in different threads however had to abandon this idea because of said stack overflows. By reducing the use of threads as much as possible, we were able to reduce the stack overflows. Replicating normal feeds or session trees now works without any issues. However for the fork trees stack overflows on the receiver device can still occasionally occur. We could not completely resolve this problem. \\
To reduce the storage size, we first had the idea to add packet types containing delete or modify commands that a user could manually append to a feed and with it remove or change older feeds. However we quickly realized, that this method would be very complicated and not generic enough to easily be replicable in different situations. The introduction of feed structures that handle storage management automatically was therefore a better suited path to take for our situation. The user does not have to concern himself with the task of creating feed continuations and children anymore and thus the risk of producing errors is reduced. While the construction of feed trees on the producer side was rather simple to implement, complications started once we tried to replicate them in the network. A lot of unexpected situations occurred because the structure on the receiver node is not at all times a complete tree and we do not know which feed will receive the next packet. We had to account for that and find solutions to cope with those problems. The use of a central DMX table where entries are assigned to categories helped a lot in this regard. It let us update the DMX values for a specific tree without affecting any other feeds on the node and thus could reduced errors in the code. \\
While there are still a lot of improvements that can be made to the system (See \cref{sec:futurework}), in its current state a functioning network can be deployed.

\section{Future Work}
\label{sec:futurework}
A lot of settings can be tweaked to optimize the packet requesting. In the session tree for example, feeds on a higher layer or the root feed could be given higher priority. If the priority is too high, a lot of unanswered want requests will be sent when no newer packet exists. If it is too low, it can take a long time until the tree finally adds a new pointer layer. Dynamically changing priorities can be something that could be looked at as well. For example if a new packet was appended to the root feed, increase the root feed's priority until the request is unsuccessful. \\
Further session trees may be optimized by changing the number of pointer packets per pointer feed or having only a pointer to a session feed every $x$ feeds. This reduces the number of pointers while still having 'pointer path' that reaches the sliding window. \\
The trees in the current state disregard unused feeds or packets. Deleting a feed only deletes it from memory but not from the device storage. Obviously the deletion of feeds from storage must be implemented to be able to let a device run over a long period of time. \\
While in the current implementation of the priority queue every priority has a certain amount of slots when processing or sending packets, it may improve the system if one slot is not representing the processing of one packet but is associated with a certain amount of computation time. Packets that take longer to be processed therefore would use up more slots than others. A similar idea could be applied to the four main tasks that are processed by the resource manager loop (see \cref{sec:loop}). Processing of a task could be limited by time or computation amount instead of a fixed number of iterations. \\
Further testing a system with more nodes over a long period of time could potentially point to some issues that have to be addressed before a reliable network can be deployed. And finally connecting it to a solar panel and deploying it outdoors will truly demonstrate if the concept of the system works. \\